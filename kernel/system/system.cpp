/**
 * File: system.cpp
 *       System Module C++ implementation.
 *
 * Author: Rambod Rahmani <rambodrahmani@autistici.org>
 *         Created on 30/08/2019.
 */

#include "constants.h"
#include <libqlk.h>
#include <log.h>
#include <apic.h>

////////////////////////////////////////////////////////////////////////////////
//                                PROCESSES                                   //
////////////////////////////////////////////////////////////////////////////////

/**
 * Maximum process priority.
 */
const natl MAX_PRIORITY	= 0xfffffff;

/**
 * Minimum process priority.
 */
const natl MIN_PRIORITY	= 0x0000001;

/**
 * Dummy processo priority.
 */
const natl DUMMY_PRIORITY = 0x0000000;

/**
 * Number of registers of the contest array field of the des_proc struct.
 */
const int N_REG = 16;

/**
 * Memory Virtual Address.
 */
typedef natq vaddr;

/**
 * Memory Physical Address.
 */
typedef natq faddr;

/**
 *
 */
typedef natq tab_entry;

/**
 * Process Descriptor. Each process has its own process descriptor, a system
 * stack and its own memory (which contains its code, data and user stack).
 * In order to be able to switch between processes and allow for a little
 * parallel execution we will have to take a full snapshot of the system state
 * (CPU, memory, devices etc..) in order to be able to come back to the
 * execution where it has been left.
 */
struct des_proc
{
    // hardware required: packed means it will use the smallest possible space
    // for struct Ball - i.e. it will cram fields together without padding
    struct __attribute__ ((packed))
    {
        natl riservato1;

        /**
         * Each process has its own system stack and the way the system stack is
         * changed moving from one process to another is up to the hardware
         * interrupt mechanism. We will place this pointer to the process system
         * stack where we know the hardware will look for it. When the process
         * is started, the CPU will save in this stack the pointer to the
         * previous stack, the content of the RFLAGS register, the previous
         * privilege level, and the address of the next instruction to be
         * executed.
         * When a process is at user level its system stack is always empty. The
         * system stack will be filled when moving to the system level and
         * emptied out when returning to user level.
         */
        vaddr system_stack;

        // due quad  a disposizione (puntatori alle pile ring 1 e 2)
        natq disp1[2];
        natq riservato2;

        // entry della IST, non usata
        natq disp2[7];
        natq riservato3;
        natw riservato4;

        /**
         * Contains the offset inside the TSS entry of the I/O bitmap. This 
         * bitmap contains one bit for each possible I/O address. The I/O
         * operations executed by the process at user level will be allowed if
         * and only if the corresponding bit of the involved I/O address is set
         * to 1. See the create_process() method to see how to disable this.
         */
        natw iomap_base;
    };

    /**
     * Current level 4 table pointer. Each process has its own. The MMU
     * intercept each and every memory related operation in the attempt of
     * translating the virtual address generated by the CPU into physical
     * address using the currently active table pointed by its internal
     * CR3 register.
     */
    faddr cr3;

    // process context: contains a copy of the CPU registers content
    natq context[N_REG];

    // process privilege level: either LEV_USER or LEV_SYSTEM
    natl cpl;
};

/**
 * Number of active user processes.
 */
volatile natl user_processes;

/**
 * Destroys the process currently pointed by 'execution' and jumps to a new
 * process. Keep in mind that it won't return to the calling function, but only
 * abort the current process and schedule a new one.
 */
extern "C" void c_abort_p();

/**
 * Returns the process descriptor for the given process id.
 * See system.s.
 *
 * @param  id  the process ID.
 */
extern "C" des_proc *des_p(natl id);

/**
 * Dummy process ID, created during initialization.
 * The dummy process is the process with the lowest priority among the ready
 * processes and it is used to avoid deadlock conditions where no process is
 * available to go under execution. The dummy process, when executed only checks
 * the number of process currently active in the system. If all the process are
 * terminate the dummy process will eventually shutdown the system.
 */
natl dummy_proc;

/**
 * Indexes for the context[] array in the des_proc struct.
 * Each CPU register has its own index.
 */
enum
{
    I_RAX,
    I_RCX,
    I_RDX,
    I_RBX,
    I_RSP,
    I_RBP,
    I_RSI,
    I_RDI,
    I_R8,
    I_R9,
    I_R10,
    I_R11,
    I_R12,
    I_R13,
    I_R14,
    I_R15
};

/**
 * Can be used to represent a process in a queue.
 */
struct proc_elem
{
    /**
     * Every time a process is created an entry in the GDT must be filled with
     * the pointer to the process descriptor. The offset of the GDT entry used
     * will also be used as the process id.
     */
    natl id;

    /**
     * There are many types of process queueing criterias. We will base our
     * processes queues on the processes priority. At any given time the process
     * under execution (pointed by 'execution') is the process with the highest
     * priority.
     */
    natl priority;
    proc_elem *next;
};

/**
 * Current Process under execution at any given time.
 */
proc_elem *execution;

/**
 * List of processes ready to be executed.
 */
proc_elem *ready_proc;

/**
 * Inserts the given process element in the given processes list. The list is
 * ordered based on each process priority. For processes with the same priority
 * the new process will be inserted at the end.
 *
 * @param  p_list  processes list where to insert the given process;
 * @param  p_elem  process to be inserted.
 */
void list_insert(proc_elem *&p_list, proc_elem *p_elem)
{
    proc_elem *pp, *prevp;

    // point to the top of the list
    pp = p_list;

    prevp = 0;

    // loop through the processes list
    while (pp != 0 && pp->priority >= p_elem->priority)
    {
        prevp = pp;
        pp = pp->next;
    }

    // insert in the ordered list
    p_elem->next = pp;

    // check if it is the top of the list
    if (prevp == 0)
	{
        // insert process in the top
        p_list = p_elem;
    }
    else
    {
        // change previous process next element pointer
        prevp->next = p_elem;
    }
}

/**
 * Removes from the given processes list the process having the highest priority
 * and returns it using p_elem.
 * Because the processes list is kept ordered based on each process element
 * priority, the only thing we have to do is to remove the process placed on the
 * top of the list.
 *
 * @param  p_list  the processes list where to remove the process from;
 * @param  p_elem  pointer to the process elem removed from the list.
 */
void list_remove(proc_elem *&p_list, proc_elem *&p_elem)
{
    // copies the top element of the list into p_elem (usually execution)
    p_elem = p_list;

    // chekc if the list is not empty
    if (p_list)
    {
        // remove top element
        p_list = p_list->next;
    }

    // check if the removed element is not 0
    if (p_elem)
    {
        // remove next pointer
        p_elem->next = 0;
    }
}

/**
 * Inserts the process currently under execution at the top of the ready_proc
 * queue. Once the process has been inserted in this queue a new process will be
 * scheduled (using a call to 'schedule') among all the active processes on the
 * system using the priority criteria. Keep in mind that using this method we
 * are not inserting the process as we do using the list_insert() method. We are
 * not taking into account the process priority. This is because the process
 * currently under execution is the one with the highest priority of course and
 * since it is already under execution, in case of need we don't want to make it
 * wait further.
 */
extern "C" void ins_ready_proc()
{
    execution->next = ready_proc;
    ready_proc = execution;
}

/**
 * Generally speacking, each process can be found in one of the following
 * states:
 *  1. execution: the process is currently under execution by the CPU;
 *  2. ready: the process is ready to be executed by the CPU;
 *  3. wait: the process is not ready to be executed by the CPU as it is waiting
 *           for certain conditions to be met.
 *
 * Selects the next process to be placed under execution. Since the processes
 * list is ordered according to priority we can just remove the process on the
 * top of the list.
 */
extern "C" void schedule(void)
{
    // remove process from the top of 'ready_proc' and place it in 'execution'
    list_remove(ready_proc, execution);
}

////////////////////////////////////////////////////////////////////////////////
//                                 SEMAPHORES                                 //
////////////////////////////////////////////////////////////////////////////////
// We will be using semaphores for two main reasons: mutual exclusion (mutex)
// and synchronization. Semaphores are allocated once and never deallocated: the
// assumption we make is that there is a finite number of avilable sempahore
// which can be used by the user program (multiple processes program) to share
// a given area of memory (each process also has its own memory space).
// Each semaphore is descripted by the des_sem struct.

/**
 * Semaphore element descriptor.
 */
struct des_sem
{
    /**
     * When the sempahore is used for mutual exclusion it is a positive number
     * and represents the number of simultaneously active process. Each process
     * receiving the mutex lock must decrement this of 1.
     *
     * When the semaphore is used for synchronization must be initialized to a
     * value lower or equal to 0 (<= 0). In this case one process is waiting for
     * other processes to be activated before executing and each of these
     * processes will increment counter by 1.
     */
    int counter;

    // processes waiting for this semaphore
    proc_elem *pointer;
};

/**
 * Available semaphore descriptors.
 */
des_sem array_dess[MAX_SEM];

/**
 * Initializes a semaphore with the given value for the counter field and
 * returns the initialized semaphore ID.
 */
extern "C" natl sem_ini(int);

/**
 * Checks if the given semaphore ID is valid (belongs to an allocated
 * semaphore).
 */
bool sem_valido(natl sem);

/**
 * Waits for the semaphore identified by the given id.
 *
 * @param  id  the semaphore id.
 */
extern "C" void c_sem_wait(natl sem)
{
    // semaphore pointer
    des_sem *s;

    // check if the given semaphore id is valid
    if (!sem_valido(sem))
    {
        // if not, print a warning log message
        flog(LOG_WARN, "Invalid semaphore: %d", sem);

        // abort current process under execution
        c_abort_p();

        // just return to the calling function
        return;
    }

    // otherwise, retrieve pointer to the specified semaphore
    s = &array_dess[sem];

    // decrease semaphore counter
    (s->counter)--;

    // if the semaphore counter is lower than zero
    if ((s->counter) < 0)
    {
        // insert process in the waiting list
        list_insert(s->pointer, execution);

        // schedule next process
        schedule();
    }
}

/**
 * This method is called by a process to notify all waiting processes that it
 * has unlocked the reference object.
 *
 * @param  sem  the semaphore id.
 */
extern "C" void c_sem_signal(natl sem)
{
    // semaphore pointer
    des_sem *s;

    // process pointer
    proc_elem *proc;

    // check if the given semaphore id is valid
    if (!sem_valido(sem))
    {
        // if not, print a warning message to the console
        flog(LOG_WARN, "Invalid semaphore: %d", sem);

        // abort current process under execution
        c_abort_p();

        // just return to the calling function
        return;
    }

    // retrieve semaphore identified by the given id
    s = &array_dess[sem];

    // increment semaphore counter
    (s->counter)++;

    // check if the semaphore counter is below or equal to zero
    if ((s->counter) <= 0)
    {
        // remove a process from the semaphore wait list into 'proc'
        list_remove(s->pointer, proc);

        // preemption: insert current process into the ready processes list
        ins_ready_proc();

        // preemption: insert retrieved process into the ready processes list
        list_insert(ready_proc, proc);

        // schedule: both the current process and the process retrieved from the
        // semaphore wai list must be inserted in the ready processes list and
        // the system must reschedule again in order to make sure that at any
        // given time the process with the highest priority is under execution
        schedule();
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                   TIMER                                    //
////////////////////////////////////////////////////////////////////////////////
// The system timer can be used to implement the delay function. In order to do
// so we have a suspended processes queue (all of them have called the delay()
// primitive) and will initialize the Timer with the required time constant. The
// Timer driver (c_driver_td) is called every time the timer sends an interrupt
// request and will check the suspended processes queue. If the duration of the
// delay for a given timer request is over, the process will be placed in the
// system ready process queue in order to be available for rescheduling.
////////////////////////////////////////////////////////////////////////////////

/**
 * Timer request. Each timer request has a duration, the requesting process
 * pointer and a pointer to the next timer request.
 */
struct timer_req
{
    // delay duration
    natl duration;

    // next delay request
    timer_req *p_req;

    // suspended process
    proc_elem *pp;
};

/**
 * Timer requests queue. The queue is ordered based on the timer requests delay
 * duration. The request with the highest duration is placed at the bottom of
 * the queue.
 */
timer_req *timer_requests;

/**
 * Places the given timer request in the requests queue.
 */
void insert_timer_req(timer_req *p);

/**
 * C++ implementation for the delay() primitive.
 */
extern "C" void c_delay(natl n)
{
    // timer request
    timer_req *p;

    // allocate memory space for new timer request
    p = static_cast<timer_req*>(alloca(sizeof(timer_req)));

    // set delay duration
    p->duration = n;

    // set requesting process
    p->pp = execution;

    // place the request in the queue
    insert_timer_req(p);

    // schedule a new process
    schedule();
}

/**
 * Places the given timer request in the requests queue. This methods loops
 * through the timer requests already present in the queue and places the new
 * request based on its dealy duration. The process with the highest duration is
 * placed at the bottom of the queue and its duration is decreased everytime
 * an item in the queue is skipped.
 *
 * @param  p  the request to be placed in the queue.
 */
void insert_timer_req(timer_req *p)
{
    // current timer request
    timer_req *r;

    // previous timer request
    timer_req *prev;

    // insert result
    bool ins;

    // pointer to the top of the timer requests queue
    r = timer_requests;

    // the loop must be yet started
    prev = 0;

    // no insert made so far
    ins = false;

    // loop through timer requests queue to find a spot
    while (r != 0 && !ins)
    {
        // check if the given timer request is higher
        if (p->duration > r->duration)
        {
            // if so, decrease the duration
            p->duration -= r->duration;

            // skip to the next timer request in the queue
            prev = r;
            r = r->p_req;
        }
        else
        {
            // if not, we have got the right spot
            ins = true;
        }
    }

    // place the given timer request before the one current pointed by r
    p->p_req = r;
    if (prev != 0)
    {
        prev->p_req = p;
    }
    else
    {
        timer_requests = p;
    }

    if (r != 0)
    {
        r->duration -= p->duration;
    }
}

/**
 * In case of fatal errors, the following function can be used to shutdown the
 * system. The interrupt mechanism will be used to call the c_panic subroutine.
 */
extern "C" void panic(cstr msg) __attribute__ (( noreturn ));

////////////////////////////////////////////////////////////////////////////////
//                                 EXCEPTIONS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * Descriptive string for the exceptions.
 *
 * The processor will sometimes need to signal your kernel. Something major may
 * have happened, such as a divide-by-zero, or a page fault. To do this, it uses
 * the first 32 interrupts. It is therefore doubly important that all of these
 * are mapped and non-NULL - else the CPU will triple-fault and reset (bochs
 * will panic with an 'unhandled exception' error).
 */
static const char *exceptions[] =
{
    "Division by zero exception",   // 0
    "Debug exception",              // 1
    "Non maskable interrupt",       // 2
    "Breakpoint exception",         // 3
    "Overflow exception",           // 4
    "Out of bounds exception",      // 5
    "Invalid opcode exception",     // 6
    "No coprocessor exception",     // 7
    "Double fault",                 // 8, pushes an error code
    "Coprocessor segment overrun",  // 9
    "Bad TSS",                      // 10, pushes an error code
    "Segment not present",          // 11, pushes an error code
    "Stack fault",                  // 12, pushes an error code
    "General protection fault",     // 13, pushes an error code
    "Page fault",                   // 14, pushes an error code
    "Unknown interrupt exception",  // 15
    "Coprocessor fault",            // 16
    "Alignment check exception",    // 17
    "Machine check exception",      // 18
    "SIMD exception",               // 19
};

/**
 * Dumps the current process data.
 *
 * @param  id   id of the process to be dumped;
 * @param  sev  severity to be used for the log message.
 */
void process_dump(natl id, log_sev sev);

/**
 * All exception are handled in the same way. This function writes a log message
 * containing info about the handled exception, dumps the current process data 
 * which caused the exception data and aborts it.
 *
 * @param  type  interrupt type;
 * @param  err   error type;
 * @param  eip   value addressed by %rsp.
 */
extern "C" void handle_exception(int type, natq err, addr eip)
{
    // log warning message about the Exception
    flog(LOG_WARN, "Exception %ld, error = %lx, EIP = %p\n", type, err, eip);

    // dump current process info
    process_dump(execution->id, LOG_WARN);

    // abort current process
    c_abort_p();
}

// (*il microprogramma di gestione delle eccezioni di page fault lascia in cima
//   alla pila (oltre ai valori consueti) una parola quadrupla i cui 4 bit meno
//   significativi specificano piu' precisamente il motivo per cui si e'
//   verificato un page fault. Il significato dei bit e' il seguente:
//   - prot: se questo bit vale 1, il page fault si e' verificato per un errore
//   di protezione: il processore si trovava a livello utente e la pagina
//   era di livello sistema (bit US = 0 in una qualunque delle tabelle
//   dell'albero che porta al descrittore della pagina). Se prot = 0, la pagina
//   o una delle tabelle erano assenti (bit P = 0)
//   - write: l'accesso che ha causato il page fault era in scrittura (non
//   implica che la pagina non fosse scrivibile)
//   - user: l'accesso e' avvenuto mentre il processore si trovava a livello
//   utente (non implica che la pagina fosse invece di livello sistema)
//   - res: uno dei bit riservati nel descrittore di pagina o di tabella non
//   avevano il valore richiesto (il bit D deve essere 0 per i descrittori di
//   tabella, e il bit pgsz deve essere 0 per i descrittori di pagina)
struct pf_error
{
	natq prot  : 1;
	natq write : 1;
	natq user  : 1;
	natq res   : 1;
	natq pad   : 60; // bit non significativi
};

/**
 *
 */
bool c_routine_pf();

/**
 *
 */
extern "C" vaddr readCR2();

/**
 *
 */
extern "C" faddr readCR3();

/**
 *
 */
extern "C" natq end;	// ultimo indirizzo del codice sistema (fornito dal collegatore)

/**
 * True if a Page Fault is currently being handled.
 */
bool in_pf = false;

/**
 * Called before calling the actual Page Fault routine. This subroutine makes
 * additional checks before calling the actual page fault handler.
 *
 * @param  tipo   14;
 * @param  errore
 * @param  rip    address of the instruction which caused the page fault.
 */
extern "C" void c_pre_routine_pf(int tipo, pf_error errore, addr rip)
{
    // check if a page fault is currently being handled
    if (in_pf)
    {
        // if so, panic, there must be an error in the system module
        panic("Recorsive Page Fault. STOP.");
    }

    // set currently handling page fault to true
    in_pf = true;

	// (* il sistema non e' progettato per gestire page fault causati
	//   dalle primitie di nucleo. Se cio' si e' verificato,
	//   si tratta di un bug
    if ((errore.user == 0 && rip < &end)|| errore.res == 1)
    {
		vaddr v = readCR2();
		flog(LOG_ERR, "PAGE FAULT a %p, rip=%lx", v, rip);

        if (v < DIM_PAGINA)
        {
            flog(LOG_ERR, "Probabile puntatore NULL");
        }

		flog(LOG_ERR, "dettagli: %s, %s, %s, %s",
			errore.prot  ? "protezione"	: "pag/tab assente",
			errore.write ? "scrittura"	: "lettura",
			errore.user  ? "da utente"	: "da sistema",
			errore.res   ? "bit riservato"	: "");
		panic("errore di sistema");
	}
	// *)

	// (* l'errore di protezione non puo' essere risolto: il processo ha
	//    tentato di accedere ad indirizzi proibiti (cioe', allo spazio
	//    sistema)
	if (errore.prot == 1) {
		flog(LOG_WARN, "errore di protezione: rip=%lx, ind=%lx, %s, %s", rip, readCR2(),
			errore.write ? "scrittura"	: "lettura",
			errore.user  ? "da utente"	: "da sistema");
		c_abort_p();
		goto out;
	}

	// (* proviamo a caricare la pagina/tabella. Il caricamento potrebbe
	// ancora fallire perche' abbiamo finito lo spazio nello swap o perche'
	// il processo ha tentato di accedere ad una zona non mappata.)
	if (!c_routine_pf()) {
		vaddr v = readCR2();
		flog(LOG_WARN, "PAGE FAULT a %p, rip=%lx non risolto", v, rip);
		c_abort_p();
	}
out:
	in_pf = false;	//* fine della gestione del page fault
}

////////////////////////////////////////////////////////////////////////////////
//                                  FRAMES                                    //
////////////////////////////////////////////////////////////////////////////////
// frame = physical memory page
// page = virtual memory page

/**
 * This structure describes a memory frame.
 *
 * The entire available memory of the system is devided into two main blocks:
 *  M1: contains data structures and subroutines relative to the operating
 *      system;
 *  M2: contains the available frames (physical pages) which can be used to
 *      store paging tables (always permanent) and the user virtual pages.
 */
struct des_frame
{
    /**
     * Each memory frame can contain 
     * -1 = free
     *  0 = page
     * >0 = table
     */
    int	livello;

    /**
     * Permanent or removable page.
     */
    bool residente;

    /**
     * Frame content owner process ID.
     */
    natl processo;

    /**
     * Statistics counter.
     */
	natl contatore;

	// blocco da cui l'entita' contenuta nel frame era stata caricata
	natq ind_massa;

	// per risparmiare un po' di spazio uniamo due campi che
	// non servono mai insieme:
	// - ind_virtuale serve solo se il frame e' occupato
	// - prossimo_libero serve solo se il frame e' libero
	union {
		// indirizzo virtuale che permette di risalire al
		// descrittore che punta all'entita' contenuta nel
		// frame. Per le pagine si tratta di un qualunque
		// indirizzo virtuale interno alla pagina. Per le
		// tabelle serve un qualunque indirizzo virtuale la
		// cui traduzione passa dalla tabella.
		vaddr	ind_virtuale;
		des_frame*	prossimo_libero;
	};
};

/**
 * Frame descriptors array allocated in M1.
 */
des_frame* vdf;

/**
 * Physical address of the first frame available in the M2 memory.
 */
faddr primo_frame_utile;

/**
 * Number of frames contained in the M2 memory.
 */
natq N_DF;

/**
 * First available frame descriptor pointer.
 */
des_frame* frame_liberi;

// dato un indirizzo di un frame restituisce un puntatore al
// corrispondente descrittore
des_frame* descrittore_frame(faddr indirizzo_frame)
{
	if (indirizzo_frame < primo_frame_utile)
		return 0;
	natq indice = (indirizzo_frame - primo_frame_utile) / DIM_PAGINA;
	if (indice >= N_DF)
		return 0;
	return &vdf[indice];
}

// dato un puntatore ad un descrittore di frameestituisce
// l'indirizzo del primo byte del frame corrispondente
faddr indirizzo_frame(des_frame* df)
{
	natq indice = df - &vdf[0];
	return primo_frame_utile + indice * DIM_PAGINA;
}

// restituisce il piu' piccolo numero maggiore o uguale ad a
// e multiplo di m
natq allinea(natq a, natq m)
{
	return (a + m - 1) & ~(m - 1);
}

/**
 * Called during initialization. All the available memory not yet occupied is
 * used to allocate page frames. A page, memory page, or virtual page is a
 * fixed-length contiguous block of virtual memory. Similarly, a page frame is
 * the smallest fixed-length contiguous block of physical memory into which
 * memory pages are mapped by the operating system.
 */
bool init_des_frame()
{
	faddr vdf_start;
	// L'array di decrittori di frame comincia subito dopo
	// la fine del programma
	vdf_start = allinea(reinterpret_cast<natq>(&end), sizeof(natq));
	// N_DPF e' il numero di frame di cui sara' composta M2.
	// Per calcolarlo dobbiamo tenere conto che ci servira' un des_frame
	// per ogni frame.
	N_DF = (MEM_TOT - vdf_start) / (DIM_PAGINA + sizeof(des_frame));
	// M1 finisce dopo la fine dell'array dpf;
	natq fine_M1 = vdf_start + N_DF * sizeof(des_frame);
	// primo_frame_utile e' il primo frame che inizia dopo la fine di M1
	primo_frame_utile = allinea(fine_M1, DIM_PAGINA);

	// creiamo la lista dei frame liberi, che inizialmente contiene
	// tutti i frame di M2
	vdf = reinterpret_cast<des_frame*>(vdf_start);
	frame_liberi = &vdf[0];
	for (natl i = 0; i < N_DF - 1; i++) {
		vdf[i].livello = -1;
		vdf[i].prossimo_libero = &vdf[i + 1];
	}
	vdf[N_DF - 1].livello = -1;
	vdf[N_DF - 1].prossimo_libero = 0;

	return true;
}

// estrea un frame libero dalla lista, se non vuota
des_frame* alloca_frame_libero()
{
	des_frame* p = frame_liberi;
	if (frame_liberi != 0)
		frame_liberi = frame_liberi->prossimo_libero;
	return p;
}

/**
 * Frees the given memory frame.
 *
 * @param  df  memory descriptor of the frame to be freed.
 */
void rilascia_frame(des_frame* df)
{
    df->livello = -1;
    df->prossimo_libero = frame_liberi;
    frame_liberi = df;
}

/**
 * @param  proc
 * @param  liv
 * @param  ind_virtuale
 */
des_frame* scegli_vittima(natl proc, int liv, vaddr ind_virtuale);

/**
 * @param  proc
 * @param  livello
 * @param  ind_virt
 */
des_frame* alloca_frame(natl proc, int livello, vaddr ind_virt);

////////////////////////////////////////////////////////////////////////////////
//                               MEMORY PAGING                                //
////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
static const natq BIT_SEGNO = (1UL << 47);

/**
 *
 */
static const natq MASCHERA_MODULO = BIT_SEGNO - 1;

// restituisce la versione normalizzata (16 bit piu' significativi uguali al
// bit 47) dell'indirizzo a
static inline vaddr norm(vaddr a)
{
	return (a & BIT_SEGNO) ? (a | ~MASCHERA_MODULO) : (a & MASCHERA_MODULO);
}

// restituisce la dimensione di una regione di livello liv
static inline natq dim_region(int liv)
{
	natq v = 1UL << (liv * 9 + 12);
	return v;
}

// dato un indirizzo 'a', restituisce l'indirizzo della
// regione di livello 'liv' a cui 'a' appartiene
static inline vaddr base(vaddr v, int liv)
{
	natq mask = dim_region(liv) - 1;
	return v & ~mask;
}

// copia 'n' descrittori a partire da quello di indice 'i' dalla
// tabella di indirizzo 'src' in quella di indirizzo 'dst'
void copy_des(faddr src, faddr dst, natl i, natl n)
{
	natq *pdsrc = reinterpret_cast<natq*>(src),
	     *pddst = reinterpret_cast<natq*>(dst);
	for (natl j = i; j < i + n && j < 512; j++)
		pddst[j] = pdsrc[j];
}

// indirizzo virtuale di partenza delle varie zone della memoria
// virtuale dei proceii
/**
 * Starting Virtual Address of the shared System memory area.
 */
const vaddr ini_sis_c = norm(I_SIS_C * dim_region(3));

/**
 * Starting Virtual Address of the private System memory area.
 */
const vaddr ini_sis_p = norm(I_SIS_P * dim_region(3));

/**
 * Starting Virtual Address of the I/O Module memory area.
 */
const vaddr ini_mio_c = norm(I_MIO_C * dim_region(3));

/**
 * Starting Virtual Address of the shared User memory area.
 */
const vaddr ini_utn_c = norm(I_UTN_C * dim_region(3));

/**
 * Starting Virtual Address of the private User memory area.
 */
const vaddr ini_utn_p = norm(I_UTN_P * dim_region(3));

/**
 * Address of the first byte not included in the shared System memory area.
 */
const vaddr fin_sis_c = ini_sis_c + dim_region(3) * N_SIS_C;

/**
 * Address of the first byte not included in the private System memory area.
 */
const vaddr fin_sis_p = ini_sis_p + dim_region(3) * N_SIS_P;

/**
 * Address of the first byte not included in the I/O Module memory area.
 */
const vaddr fin_mio_c = ini_mio_c + dim_region(3) * N_MIO_C;

/**
 * Address of the first byte no included in the shared User memory area.
 */
const vaddr fin_utn_c = ini_utn_c + dim_region(3) * N_UTN_C;

/**
 * Address of the first byte not included in the private User memory area.
 */
const vaddr fin_utn_p = ini_utn_p + dim_region(3) * N_UTN_P;

/**
 * Constants used to work with page descriptors and table descriptors bits.
 */

/**
 * Segment descriptor
 * ------------------
 * In memory addressing for Intel x86 computer architectures, segment
 * descriptors are a part of the segmentation unit, used for translating a
 * logical address to a linear address. Segment descriptors describe the memory
 * segment referred to in the logical address.
 *
 * In x86-64, the code segment descriptor has the following form:
 *
 * ------------------------------------------------------------------------------------------------
 * 31       —       24 23 22 21 20  19       —        16 15 14 13 12 11 10 9 8  7 — 0
 * Base Address[31:24] G  D  L  AVL Segment Limit[19:16] P  DPL   1  1  C  R A  Base Address[23:16]
 * Base Address[15:0]                                    Segment Limit[15:0]
 * ------------------------------------------------------------------------------------------------
 *
 * Where the fields stand for:
 * Base Address
 *   32 bit starting memory address of the segment;
 * 
 * Segment Limit
 *   20 bit length of the segment. (More specifically, the address of the last
 *   accessible data, so the length is one more that the value stored here.) How
 *   exactly this should be interpreted depends on other bits of the segment
 *   descriptor;
 * 
 * G=Granularity
 *   If clear, the limit is in units of bytes, with a maximum of 220 bytes. If
 *   set, the limit is in units of 4096-byte pages, for a maximum of 232 bytes;
 *
 * D=Default operand size
 *   If clear, this is a 16-bit code segment; if set, this is a 32-bit segment;
 *
 * L=Long-mode segment
 *   If set, this is a 64-bit segment (and D must be zero), and code in this
 *   segment uses the 64-bit instruction encoding;
 *
 * AVL=Available
 *   For software use, not used by hardware;
 *
 * P=Present
 *   If clear, a "segment not present" exception is generated on any reference
 *   to this segment;
 *
 * DPL=Descriptor privilege level
 *   Privilege level required to access this descriptor;
 *
 * C=Conforming
 *   Code in this segment may be called from less-privileged levels;
 *
 * R=Readable
 *   If clear, the segment may be executed but not read from;
 *
 * A=Accessed
 *   This bit is set to 1 by hardware when the segment is accessed, and cleared
 *   by software.
 */

/**
 * Presence Bit Mask.
 */
const natq BIT_P    = 1U << 0;

/**
 * Read/Write Bit Mask.
 */
const natq BIT_RW   = 1U << 1;

/**
 * User/System Bit Mask.
 */
const natq BIT_US   = 1U << 2;

/**
 * Page Write Through Bit Mask.
 */
const natq BIT_PWT  = 1U << 3;

/**
 * Page Cache Disabled Mask.
 */
const natq BIT_PCD  = 1U << 4;

/**
 * Access Bit Mask.
 */
const natq BIT_A    = 1U << 5;

/**
 * Dirty Bit Mask.
 */
const natq BIT_D    = 1U << 6; // il bit "dirty"
const natq BIT_PS   = 1U << 7; // il bit "page size"
const natq BIT_ZERO = 1U << 9; // (* nuova pagina, da azzerare *)

const natq ACCB_MASK     = 0x00000000000000FF; // maschera per il byte di accesso
const natq ADDR_MASK     = 0x7FFFFFFFFFFFF000; // maschera per l'indirizzo
const natq INDMASS_MASK  = 0x7FFFFFFFFFFFF000; // maschera per l'indirizzo in mem. di massa
const natq INDMASS_SHIFT = 12;	    // primo bit che contiene l'ind. in mem. di massa

/**
 *
 */
bool  extr_P(tab_entry descrittore)
{ // (
	return (descrittore & BIT_P); // )
}

/**
 *
 */
bool extr_D(tab_entry descrittore)
{ // (
	return (descrittore & BIT_D); // )
}

/**
 *
 */
bool extr_A(tab_entry descrittore)
{ // (
	return (descrittore & BIT_A); // )
}

/**
 *
 */
bool extr_ZERO(tab_entry descrittore)
{ // (
	return (descrittore & BIT_ZERO); // )
}

/**
 *
 */
faddr extr_IND_FISICO(tab_entry descrittore)
{ // (
	return descrittore & ADDR_MASK; // )
}

/**
 *
 */
natq extr_IND_MASSA(tab_entry descrittore)
{ // (
	return (descrittore & INDMASS_MASK) >> INDMASS_SHIFT; // )
}

/**
 *
 */
void set_P(tab_entry& descrittore, bool bitP)
{ // (
	if (bitP)
		descrittore |= BIT_P;
	else
		descrittore &= ~BIT_P; // )
}

/**
 *
 */
void set_A(tab_entry& descrittore, bool bitA)
{ // (
	if (bitA)
		descrittore |= BIT_A;
	else
		descrittore &= ~BIT_A; // )
}

/**
 *
 */
void set_ZERO(tab_entry& descrittore, bool bitZERO)
{
	if (bitZERO)
		descrittore |= BIT_ZERO;
	else
		descrittore &= ~BIT_ZERO;
}

// (* definiamo anche la seguente funzione:
//    clear_IND_M: azzera il campo M (indirizzo in memoria di massa)
void clear_IND_MASSA(tab_entry& descrittore)
{
	descrittore &= ~INDMASS_MASK;
}

/**
 *
 */
void  set_IND_FISICO(tab_entry& descrittore, faddr ind_fisico) //
{ // (
	clear_IND_MASSA(descrittore);
	descrittore |= ind_fisico & ADDR_MASK; // )
}

/**
 *
 */
void set_IND_MASSA(tab_entry& descrittore, natq ind_massa)
{ // (
	clear_IND_MASSA(descrittore);
	descrittore |= (ind_massa << INDMASS_SHIFT); // )
}

/**
 *
 */
void set_D(tab_entry& descrittore, bool bitD)
{
	if (bitD)
		descrittore |= BIT_D;
	else
		descrittore &= ~BIT_D;
}

/**
 *
 */
bool  extr_PS(tab_entry descrittore)
{
	return (descrittore & BIT_PS);
}

// dato un indirizzo virtuale 'ind_virt' ne restituisce
// l'indice del descrittore corrispondente nella tabella di livello 'liv'
int i_tab(vaddr ind_virt, int liv)
{
	int shift = 12 + (liv - 1) * 9;
	natq mask = 0x1ffUL << shift;
	return (ind_virt & mask) >> shift;
}

/**
 * Retrieves the table entry for the given table address and index.
 *
 * @param  tab    table address;
 * @param  index  entry index.
 */
tab_entry& get_entry(faddr tab, natl index)
{
	tab_entry *pd = reinterpret_cast<tab_entry*>(tab);
	return  pd[index];
}

// dato un identificatore di processo, un livello e
// un indirizzo virtuale 'ind_virt', restituisce un riferimento
// all'entrata di quel livello relativo alla pagina che
// contiene 'ind_virt' (tutte le tabelle di livello
// precedente devono essere gia' presenti)
tab_entry& get_des(natl processo, int livello, vaddr ind_virt)
{
	des_proc *p = des_p(processo);
	if (!p) {
		flog(LOG_ERR, "get_des(%d): processo non trovato", processo);
		panic("errore interno");
	}
	faddr tab = p->cr3;
	for (int i = 4; i > livello; i--) {
		tab_entry e = get_entry(tab, i_tab(ind_virt, i));
		if (!extr_P(e))
			panic("P=0 non ammesso");
		tab = extr_IND_FISICO(e);
	}
	return get_entry(tab, i_tab(ind_virt, livello));
}

/**
 * Loads the given address in the CPU CR3 register.
 *
 * @param  dir  the address to be loaded.
 */
extern "C" void loadCR3(faddr dir);

/**
 * Reads and returns the current address contained in the CPU CR3 register.
 */
extern "C" faddr readCR3();

//invalida il TLB
extern "C" void invalida_TLB();

// mappa la memoria fisica in memoria virtuale, inclusa l'area PCI
// (copiamo la finestra gia' creata dal boot loader)
bool crea_finestra_FM(faddr tab4)
{
    faddr boot_dir = readCR3();

    copy_des(boot_dir, tab4, I_SIS_C, N_SIS_C);

    return true;
}

/**
 *
 */
const natl MAX_IRQ  = 24;

/**
 *
 */
proc_elem *a_p[MAX_IRQ];

/**
 *
 */
natq alloca_blocco();

/**
 *
 */
des_frame* swap(natl proc, int livello, vaddr ind_virt);

/**
 *
 */
bool crea(natl proc, vaddr ind_virt, int liv, natl priv)
{
    tab_entry& dt = get_des(proc, liv + 1, ind_virt);

    bool bitP = extr_P(dt);

    if (!bitP)
    {
        natl blocco = extr_IND_MASSA(dt);

        if (!blocco)
        {
            if (! (blocco = alloca_blocco()) )
            {
                flog(LOG_ERR, "swap pieno");

                return false;
            }

            set_IND_MASSA(dt, blocco);
            set_ZERO(dt, true);
            dt = dt | BIT_RW;

            if (priv == LEV_USER) dt = dt | BIT_US;
        }

        if (liv > 0)
        {
            des_frame *df = swap(proc, liv, ind_virt);

            if (!df)
            {
                flog(LOG_ERR, "swap(%d, %d, %p) fallita",
					proc, liv, ind_virt);

                return false;
            }

            df->residente = (priv == LEV_SYSTEM);
        }
    }

    return true;
}

/**
 *
 */
bool crea_pagina(natl proc, vaddr ind_virt, natl priv)
{
    for (int i = 3; i >= 0; i--)
    {
        if (!crea(proc, ind_virt, i, priv))
        {
            return false;
        }
    }

    return true;
}

/**
 *
 */
bool crea_pila(natl proc, vaddr bottom, natq size, natl priv)
{
    size = allinea(size, DIM_PAGINA);

    for (vaddr ind = bottom - size; ind != bottom; ind += DIM_PAGINA)
    {
        if (!crea_pagina(proc, ind, priv))
        {
            return false;
        }
    }

    return true;
}

/**
 *
 */
faddr carica_pila_sistema(natl proc, vaddr bottom, natq size)
{
    des_frame *dp = 0;

    for (vaddr ind = bottom - size; ind != bottom; ind += DIM_PAGINA)
    {
        dp = swap(proc, 0, ind);

        if (!dp)
        {
            return 0;
        }

        dp->residente = true;
    }

    return indirizzo_frame(dp) + DIM_PAGINA;
}

/**
 *
 */
faddr crea_tab4()
{
    des_frame* df = alloca_frame_libero();

    // check if the frame descriptor allocation was succesful
    if (df == 0)
    {
        flog(LOG_ERR, "Unable to allocate Tab4.");
        panic("Error while creating Tab4.");
    }
	df->livello = 4;
	df->residente = true;
	df->processo = execution->id;
	faddr tab4 = indirizzo_frame(df);
	memset(reinterpret_cast<void *>(tab4), 0, DIM_PAGINA);

	return tab4;
}

/**
 * Allocates a TSS for the given process descriptor. Loops through available TSS
 * descriptor entries in the GDT to find an empty one. If one is found it will
 * be initialized with the process descriptor fields and the TSS entry offset is
 * returned, otherwise the function will return 0.
 *
 * @param  des_proc  the process descriptor for the process TSS being allocated;
 *
 * @return  the TSS offset in the GDT or 0 if the TSS allocation fails.
 */
extern "C" natl allocate_tss(des_proc*);

/**
 * Clears the TSS entry for the given process ID.
 *
 * @param  off  the TSS offset of the process being destroyed.
 */
extern "C" void clear_tss(int off);

/**
 *
 */
const natl BIT_IF = 1L << 9;

/**
 * Retrieves a valid process id using the given process TSS offset.
 *
 * @param  tss_off  Process TSS offset.
 */
extern "C" natl tss_to_id(natl tss_off);

/**
 * Returns the TSS offset for the given process ID. This method will ultimately
 * call the conv_id_to_tss macro defined in system/system.s
 *
 * @param  id  process ID.
 */
extern "C" natl id_to_tss(natl id);

/**
 *
 */
void crea_tab4(faddr dest)
{
	faddr pdir = readCR3();

	memset(reinterpret_cast<void*>(dest), 0, DIM_PAGINA);

	copy_des(pdir, dest, I_SIS_C, N_SIS_C);
	copy_des(pdir, dest, I_MIO_C, N_MIO_C);
	copy_des(pdir, dest, I_UTN_C, N_UTN_C);
}

/**
 *
 */
void rilascia_tutto(faddr tab4, natl i, natl n);

/**
 * Creates a new process with the given parameters.
 * For each process a des_proc, proc_elem and system stack must be allocated.
 * Once a process has been initialized it will be inserted in the ready_proc
 * queue and will eventually be scheduled and executed sooner or later. The
 * execution will take place when the process is pointed by 'execution' which
 * will result in a call to the load_state and a final iretq.
 *
 * @param  f     function address for the process %RIP register; for
 *               simplicity we will assume that the process body is
 *               represented by a void function having an integer parameter
 *               only;
 * @param  a     f function integer parameter;
 * @param  prio  process priority level;
 * @param  liv   process privilege level;
 * @param  IF
 *
 * @return a pointer to the newly created process.
 */
proc_elem* create_process(void f(int), int a, int prio, char liv, bool IF)
{
    // new process element
    proc_elem *p;

    // tss offset for the gdt
    natl tss_off;

    // process identifier
    natl identifier;

    // process descriptor
    des_proc *pdes_proc;

    // process tab4
    des_frame* dpf_tab4;

    // system stack
    faddr pila_sistema;

	// allocate a new process descriptor
    pdes_proc = static_cast<des_proc*>(alloca(sizeof(des_proc)));

    // check if the space was correctly allocated
    if (pdes_proc == 0)
    {
        // otherwise go to error #1
        goto error1;
    }

    // zero out the process descriptor
    memset(pdes_proc, 0, sizeof(des_proc));

    // allocate TSS for the process and save the tss offset
	tss_off = allocate_tss(pdes_proc);

    // check if the tss offset is valid
    if (tss_off == 0)
    {
        // otherwise go to error #2
        goto error2;
    }

    // retrieve process id using process tss offset
    identifier = tss_to_id(tss_off);

    // allocate a new proc_elem
    p = static_cast<proc_elem*>(alloca(sizeof(proc_elem)));

    // check if the proc_elem was correctly allocated
    if (p == 0)
    {
        // otherwise go to error #3
        goto error3;
    }

    // set process identifier
    p->id = identifier;

    // set process priority
    p->priority = prio;

    // set process next element
    p->next = 0;

    // process tab4 creation: each process has its own level 4 table
    dpf_tab4 = alloca_frame(p->id, 4, 0);

    // check if the process tab4 was correctly allocated
    if (dpf_tab4 == 0)
    {
        // otherwise go to error #4
        goto error4;
    }

    // set table level
    dpf_tab4->livello = 4;

    // make table persistent in physical memory
    dpf_tab4->residente = true;

    // set table process
    dpf_tab4->processo = identifier;

    // set process cr3 address: this must be loaded in the CPU CR3 register
    // evereytime a process switch occurs
    pdes_proc->cr3 = indirizzo_frame(dpf_tab4);
    crea_tab4(pdes_proc->cr3);

    // create process system stack
    if (!crea_pila(p->id, fin_sis_p, DIM_SYS_STACK, LEV_SYSTEM))
    {
        // in case of errors go to error #5
        goto error5;
    }

    pila_sistema = carica_pila_sistema(p->id, fin_sis_p, DIM_SYS_STACK);
    if (pila_sistema == 0)
    {
        goto error6;
    }

    // check if the given process level is USER
    if (liv == LEV_USER)
    {
        // if so, allocate system stack
        natq* pl = reinterpret_cast<natq*>(pila_sistema);

        // set RIP: execution will continue from here when the process is
        // scheduled
        pl[-5] = reinterpret_cast<natq>(f);
        pl[-4] = SEL_CODICE_UTENTE;	        // CS (codice utente)
        pl[-3] = IF ? BIT_IF : 0;           // RFLAGS
        pl[-2] = fin_utn_p - sizeof(natq);  // RSP
        pl[-1] = SEL_DATI_UTENTE;           // SS (pila utente)

        // create user stack
        if (!crea_pila(p->id, fin_utn_p, DIM_USR_STACK, LEV_USER))
        {
            // in case of error, print a warning error log message
            flog(LOG_WARN, "Process User stack creation failed.");

            // go to error #6
            goto error6;
        }

        // set process system stack pointer to be used by the interrupt
        // mechanism when switching privilege level
        pdes_proc->system_stack = fin_sis_p;

        // keep in mind that all processes start at system level, as if an INT
        // instruction was executed, having the system stack which contains the
        // 5 long words to be used to go back to user level; this is why the
        // current RSP value points to the process system stack having skipped
        // the 5 words used by the interrupt mechanism
        pdes_proc->context[I_RSP] = fin_sis_p - 5 * sizeof(natq);

        // set function f (RIP) parameter
        pdes_proc->context[I_RDI] = a;

        //pdes_proc->context[I_FPU_CR] = 0x037f;
        //pdes_proc->context[I_FPU_TR] = 0xffff;

        // set process privilege level to user level
        pdes_proc->cpl = LEV_USER;
	
        // initialize with TSS segment length in order to disable I/O bitmap
        pdes_proc->iomap_base = DIM_DESP;

        // all remaining fields are equal to 0
    }
    else
    {
        // ( inizializzazione della pila sistema
        natq* pl = reinterpret_cast<natq*>(pila_sistema);
        pl[-6] = reinterpret_cast<natq>(f);     // RIP (codice sistema)
        pl[-5] = SEL_CODICE_SISTEMA;            // CS (codice sistema)
        pl[-4] = IF ? BIT_IF : 0;  	            // RFLAGS
        pl[-3] = fin_sis_p - sizeof(natq);      // RSP
        pl[-2] = 0;                             // SS
        pl[-1] = 0;                             // ind. rit.
                                                // (non significativo)
        //   i processi esterni lavorano esclusivamente a livello
        //   sistema. Per questo motivo, prepariamo una sola pila (la
        //   pila sistema)
        // )

        // ( inizializziamo il descrittore di processo
        pdes_proc->context[I_RSP] = fin_sis_p - 6 * sizeof(natq);
        pdes_proc->context[I_RDI] = a;

        //pdes_proc->context[I_FPU_CR] = 0x037f;
        //pdes_proc->context[I_FPU_TR] = 0xffff;

        // set current privilege level to system level
        pdes_proc->cpl = LEV_SYSTEM;

        //   tutti gli altri campi valgono 0
        // )
    }

    // return newly created process descriptor
    return p;

//
error6:	rilascia_tutto(indirizzo_frame(dpf_tab4), I_SIS_P, N_SIS_P);

//
error5:	rilascia_frame(dpf_tab4);

//
error4:	dealloca(p);

//
error3:	clear_tss(tss_off);

//
error2:	dealloca(pdes_proc);

// just return
error1:	return 0;
}

/**
 * C++ implementation for a_activate_p defined in system/system.s.
 * User Modile Primitive activate_p().
 * Copies the given process from the swap partition to the M2 memory space.
 * Returns the process ID using the RAX register.
 */
extern "C" void c_activate_p(void f(int), int a, natl prio, natl liv)
{
    // new proc_elem
    proc_elem *p;

    // id to be returned in case of failure
	natl id = 0xFFFFFFFF;

    // a priority lower than the one of the dummy process or higher than the one
    // of the calling process can not be used
    if (prio < MIN_PRIORITY || prio > execution->priority)
    {
        // print warning log message
        flog(LOG_WARN, "Invalid process priority: %d", prio);

        // abort current process
        c_abort_p();

        // just return to the calling function
        return;
    }

    // check if the given privilege level is valid
    if (liv != LEV_USER && liv != LEV_SYSTEM)
    {
        // if not, print a warning error log
        flog(LOG_WARN, "Invalid privilege level: %d", liv);

        // abort calling process
        c_abort_p();

        // just return: do not continue
        return;
    }

    // check for protection infringement: the calling processo can not activate
    // processes with a higher privilege level
    if (liv == LEV_SYSTEM && des_p(execution->id)->cpl == LEV_USER)
    {
        // if so, print a warning error log
        flog(LOG_WARN, "Protection error.");

        // abort calling process
        c_abort_p();

        // do not continue, just return
        return;
    }

    // actually create the process
    p = create_process(f, a, prio, liv, (liv == LEV_USER));

    // check if the process was correctly created
    if (p != 0)
    {
        // if so, insert it in the system ready processes queue
        list_insert(ready_proc, p);

        // increase user processes counter
        user_processes++;

        // set process id to be left in the RAX register
        id = p->id;

        // print an info log message containing the process details
        flog(LOG_INFO, "proc=%d entry=%p(%d) prio=%d liv=%d", id, f, a, prio, liv);
    }

    // retrieve current process under execution descriptor
	des_proc *self = des_p(execution->id);

    // leave initialized process id in the RAX register for the calling process
	self->context[I_RAX] = id;
}


/**
 * USER-PRIMITIVE-EXAMPLE.
 * C++ implementation for the a_getid assembly subroutine.
 */
extern "C" natl c_getid()
{
    return execution->id;
}

/**
 *
 */
void rilascia_tutto(addr tab4, natl i, natl n);

/**
 *
 */
void riassegna_tutto(natl proc, faddr tab4, natl i, natl n);

/**
 *
 */
void dealloca_blocco(natl blocco);

// rilascia tutte le strutture dati private associate al processo puntato da
// "p" (tranne il proc_elem puntato da "p" stesso)
faddr ultimo_terminato;

/**
 *
 */
extern "C" void distruggi_pila_precedente()
{
	rilascia_tutto(ultimo_terminato, I_SIS_P, N_SIS_P);
	rilascia_frame(descrittore_frame(ultimo_terminato));
	ultimo_terminato = 0;
}

/**
 * Destroys the given process.
 *
 * @param  p  the process to be destroyed.
 */
void destroy_process(proc_elem* p)
{
    // retrieve process descriptor for the given proc_elem
    des_proc* pdes_proc = des_p(p->id);

    // retrieve process tab4 address from the cr3 register
    faddr tab4 = pdes_proc->cr3;

    riassegna_tutto(p->id, tab4, I_MIO_C, N_MIO_C);

    riassegna_tutto(p->id, tab4, I_UTN_C, N_UTN_C);

    rilascia_tutto(tab4, I_UTN_P, N_UTN_P);

    ultimo_terminato = tab4;

    if (p != execution)
    {
        distruggi_pila_precedente();
    }

    // empty process TSS entry
    clear_tss(id_to_tss(p->id));

    // dealloc process descriptor
    dealloca(pdes_proc);
}

// rilascia ntab tabelle (con tutte le pagine da esse puntate) a partire da
// quella puntata dal descrittore i-esimo di tab4.
void rilascia_ric(faddr tab, int liv, natl i, natl n)
{
    for (natl j = i; j < i + n && j < 512; j++)
    {
        tab_entry& dt = get_entry(tab, j);
        natl blocco;

        if (extr_P(dt))
        {
            faddr sub = extr_IND_FISICO(dt);

            if (liv > 1)
            {
                rilascia_ric(sub, liv - 1, 0, 512);
            }

            des_frame *df = descrittore_frame(sub);
            blocco = df->ind_massa;
            rilascia_frame(df);
        }
        else
        {
            blocco = extr_IND_MASSA(dt);
        }

        dealloca_blocco(blocco);
        dt = 0;
    }
}

/**
 *
 */
void rilascia_tutto(faddr tab4, natl i, natl n)
{
	rilascia_ric(tab4, 4, i, n);
}

/**
 *
 */
void riassegna_ric(natl proc, faddr tab, int liv, natl i, natl n)
{
    for (natl j = i; j < i + n && j < 512; j++)
    {
        tab_entry& dt = get_entry(tab, j);
        
        if (extr_P(dt))
        {
            faddr sub = extr_IND_FISICO(dt);
            
            if (liv > 1)
            {
                riassegna_ric(proc, sub, liv - 1, 0, 512);
            }

            des_frame *df = descrittore_frame(sub);
            
            if (df->processo == proc)
            {
                df->processo = dummy_proc;
            }
        }
    }
}

/**
 *
 */
void riassegna_tutto(natl proc, faddr tab4, natl i, natl n)
{
	riassegna_ric(proc, tab4, 4, i, n);
}

/**
 * Aborts the current process under execution. A log message with the given text
 * and log severity is also printed. A new process is scehduled before
 * returning.
 *
 * @param  sev  log message severity;
 * @param  log  log message text.
 */
void term_cur_proc(log_sev sev, const char *log)
{
    // retrive pointer to the current process under execution
    proc_elem *p = execution;

    // destroy the current process under execution
    destroy_process(p);

    // descrease active user processes counter
    user_processes--;

    // print log message
    flog(sev, "Process %d %s", p->id, log);

    // dealloc memory space
    dealloca(p);

    // schedule next process
    schedule();
}

/**
 * C++ implementation for the terminate_p() primitive. Terminates the calling
 * process.
 */
extern "C" void c_terminate_p()
{
	term_cur_proc(LOG_INFO, "Aborted.");
}

/**
 * Aborts the process currently pointed by 'execution'. A new process will be
 * scheduled before returning.
 *
 * The only difference with c_terminate_p is that an additionally warning log is
 * also sent whem using this method. Must be used when a process is aborted as a
 * result of an occurring error.
 */
extern "C" void c_abort_p()
{
	term_cur_proc(LOG_WARN, "Current execution process aborted.");
}

/**
 * Timer driver C++ implementation: called everytime the timer sends an
 * interrupt request. The current process under execution is placed in the
 * system ready processes queue, the suspended processes queue is checked for
 * process which can be rescheduled.
 */
extern "C" void c_driver_td(void)
{
    // timer request
    timer_req *p;

    // place the current process under execution in the system ready processes
    // queue
    ins_ready_proc();

    // check if there is a timer request
    if (timer_requests != 0)
    {
        // if so, decrease the delay duration of the top most request
        timer_requests->duration--;
    }

    // loop through the timer requests queue
    while (timer_requests != 0 && timer_requests->duration == 0)
    {
        // if the delay duration is equal to zero, place the timer request
        // process in the system ready processes queue
        list_insert(ready_proc, timer_requests->pp);

        // next element in the timer requests queue
        p = timer_requests;
        timer_requests = timer_requests->p_req;

        // free memory
        dealloca(p);
	}

    // schedule new process
    schedule();
}

/**
 *
 */
void scrivi_swap(addr src, natl blocco);

/**
 *
 */
void leggi_swap(addr dest, natl blocco);

/**
 *
 */
void carica(des_frame* df)
{
	tab_entry& e = get_des(df->processo, df->livello + 1, df->ind_virtuale);
	if (extr_ZERO(e)) {
		memset((addr)indirizzo_frame(df), 0, DIM_PAGINA);
	} else {
		leggi_swap((addr)indirizzo_frame(df), df->ind_massa);
	}
}

/**
 *
 */
void scarica(des_frame* df)
{
	scrivi_swap((addr)indirizzo_frame(df), df->ind_massa);
	tab_entry& e = get_des(df->processo, df->livello + 1, df->ind_virtuale);
	set_D(e, false);
}

/**
 *
 */
void collega(des_frame *df)
{
	tab_entry& e = get_des(df->processo, df->livello + 1, df->ind_virtuale);
	set_IND_FISICO(e, indirizzo_frame(df));
	set_P(e, true);
	set_D(e, false);
	set_A(e, false);
}

/**
 *
 */
extern "C" void invalida_entrata_TLB(vaddr ind_virtuale);

/**
 *
 */
bool scollega(des_frame* df)
{
	bool bitD;
	tab_entry& e = get_des(df->processo, df->livello + 1, df->ind_virtuale);
	bitD = extr_D(e);
	bool occorre_salvare = bitD || df->livello > 0;
	set_IND_MASSA(e, df->ind_massa);
	set_P(e, false);
	if (occorre_salvare)
		set_ZERO(e, false);
	if (df->processo == execution->id)
		invalida_entrata_TLB(df->ind_virtuale);
	return occorre_salvare;	//
}

// alloca un frame destinato a contenere l'entita' del
// livello specificato, relativa all'indirizzo virtuale ind_virt
// nello spazio di indirizzamento di proc
des_frame* alloca_frame(natl proc, int livello, vaddr ind_virt)
{
	des_frame *df = alloca_frame_libero();
	if (df == 0) {
		df = scegli_vittima(proc, livello, ind_virt);
		if (df == 0)
			return 0;
		bool occorre_salvare = scollega(df);
		if (occorre_salvare)
			scarica(df);
	}
	return df;
}

// carica l'entita' del livello specificato, relativa all'indirizzo virtuale
// ind_virt nello spazio di indirizzamento di proc
des_frame* swap(natl proc, int livello, vaddr ind_virt)
{
	tab_entry e = get_des(proc, livello + 1, ind_virt);
	natq m = extr_IND_MASSA(e);
	if (!m) {
		flog(LOG_WARN,
		     "indirizzo %p fuori dallo spazio virtuale allocato",
		     ind_virt);
		return 0;
	}
	des_frame* df = alloca_frame(proc, livello, ind_virt);
	if (!df) {
		flog(LOG_WARN, "memoria esaurita");
		return 0;
	}
	df->livello = livello;
	df->residente = 0;
	df->processo = proc;
	df->ind_virtuale = ind_virt;
	df->ind_massa = m;
	df->contatore = 0;
	carica(df);
	collega(df);
	return df;
}

/**
 * Updates memory frames statistics.
 */
void stat();

/**
 * Page fault subroutine C++ implementation. A page fault (sometimes called #PF,
 * PF or hard fault) is a type of exception raised by computer hardware when a
 * running program accesses a memory page that is not currently mapped by the
 * memory management unit (MMU) into the virtual address space of a process.
 * Logically, the page may be accessible to the process, but requires a mapping
 * to be added to the process page tables, and may additionally require the
 * actual page contents to be loaded from a backing store such as a disk.
 */
bool c_routine_pf()
{
    // missing virtual address
    vaddr ind_virt = readCR2();

    // retrieve calling process id
    natl proc = execution->id;

    // update frames statistics
    stat();

    // loop through memory tables levels
    for (int i = 3; i >= 0; i--)
    {
        tab_entry d = get_des(proc, i + 1, ind_virt);

        bool bitP = extr_P(d);

        if (!bitP)
        {
            des_frame *df = swap(proc, i, ind_virt);

            if (!df)
            {
                return false;
            }
        }
    }

    return true;
}

/**
 *
 */
bool vietato(des_frame* df, natl proc, int liv, vaddr ind_virt)
{
	if (df->livello > liv && df->processo == proc &&
	    base(df->ind_virtuale, df->livello) == base(ind_virt, df->livello))
		return true;
	return false;
}

/**
 *
 */
des_frame* scegli_vittima(natl proc, int liv, vaddr ind_virt)
{
	des_frame *df, *df_vittima;
	df = &vdf[0];
	while ( df < &vdf[N_DF] &&
		(df->residente ||
		 vietato(df, proc, liv, ind_virt)))
		df++;
	if (df == &vdf[N_DF]) return 0;
	df_vittima = df;
	for (df++; df < &vdf[N_DF]; df++) {
		if (df->residente ||
		    vietato(df, proc, liv, ind_virt))
			continue;
		if (df->contatore < df_vittima->contatore ||
		    (df->contatore == df_vittima->contatore &&
		     df_vittima->livello > df->livello))
			df_vittima = df;
	}
	return df_vittima;
}

/**
 * Updates memory frames statistics used in case of page fault in order to
 * choose the frame to be emptied to make space for the incoming page.
 */
void stat()
{
    des_frame *df1, *df2;

    faddr f1, f2;

    bool bitA;

    for (natq i = 0; i < N_DF; i++)
    {
	    df1 = &vdf[i];
	
        if (df1->livello < 1)
        {
            continue;
        }


        f1 = indirizzo_frame(df1);

        for (int j = 0; j < 512; j++)
        {
            tab_entry& des = get_entry(f1, j);
            
            if (!extr_P(des))
            {
                continue;
            }

            bitA = extr_A(des);

            set_A(des, false);

            f2 = extr_IND_FISICO(des);

            df2 = descrittore_frame(f2);

            if (!df2 || df2->residente)
            {
                continue;
            }

            df2->contatore >>= 1;

            if (bitA)
            {
                df2->contatore |= 0x80000000;
            }
        }
    }

    // invalidate TLB
    invalida_TLB();
}

// funzione di supporto per carica_tutto()
bool carica_ric(natl proc, faddr tab, int liv, vaddr ind, natl n)
{
	natq dp = dim_region(liv);

	natl i = i_tab(ind, liv + 1);
	for (natl j = i; j < i + n; j++, ind += dp) {
		tab_entry e = get_entry(tab, j);
		if (!extr_IND_MASSA(e))
			continue;
		des_frame *df = swap(proc, liv, ind);
		if (!df) {
			flog(LOG_ERR, "impossibile caricare pagina virtuale %p", ind);
			return false;
		}
		df->residente = true;
		if (liv > PRELOAD_LEVEL &&
				!carica_ric(proc, indirizzo_frame(df), liv - 1, ind, 512))
			return false;
	}
	return true;
}

// carica e rende residenti tutte le pagine e tabelle allocate nello swap e
// relative alle entrate della tab4 del processo proc che vanno da i (inclusa)
// a i+n (esclusa)
bool carica_tutto(natl proc, natl i, natl n)
{
	des_proc *p = des_p(proc);

	return carica_ric(proc, p->cr3, 3, norm(i * dim_region(3)), n);
}

// super blocco (vedi e [P_SWAP] avanti)
struct superblock_t
{
	char	magic[8];
	natq	bm_start;
	natq	blocks;
	natq	directory;
	void	(*user_entry)(int);
	natq	user_end;
	void	(*io_entry)(int);
	natq	io_end;
	int	checksum;
};

// descrittore di swap (vedi [P_SWAP] avanti)
struct des_swap
{
	natl *free;		// bitmap dei blocchi liberi
	superblock_t sb;	// contenuto del superblocco
} swap_dev; 	// c'e' un unico oggetto swap

/**
 *
 */
bool swap_init();

// chiamata in fase di inizializzazione, carica in memoria fisica
// tutte le parti condivise di livello IO e utente.
bool crea_spazio_condiviso()
{
	// ( lettura del direttorio principale dallo swap
	flog(LOG_INFO, "lettura del direttorio principale...");
	addr tmp = alloca(DIM_PAGINA);
	if (tmp == 0) {
		flog(LOG_ERR, "memoria insufficiente");
		return false;
	}
	leggi_swap(tmp, swap_dev.sb.directory);
	// )

	// (  carichiamo le parti condivise nello spazio di indirizzamento del processo
	//    dummy
	faddr dummy_dir = des_p(dummy_proc)->cr3;
	copy_des((faddr)tmp, dummy_dir, I_MIO_C, N_MIO_C);
	copy_des((faddr)tmp, dummy_dir, I_UTN_C, N_UTN_C);
	dealloca(tmp);

	if (!carica_tutto(dummy_proc, I_MIO_C, N_MIO_C))
		return false;
	if (!carica_tutto(dummy_proc, I_UTN_C, N_UTN_C))
		return false;
	// )

	// ( copiamo i descrittori relativi allo spazio condiviso anche nel direttorio
	//   corrente, in modo che vengano ereditati dai processi che creeremo in seguito
	faddr my_dir = des_p(execution->id)->cr3;
	copy_des(dummy_dir, my_dir, I_MIO_C, N_MIO_C);
	copy_des(dummy_dir, my_dir, I_UTN_C, N_UTN_C);
	// )

	invalida_TLB();
	return true;
}

////////////////////////////////////////////////////////////////////////////////
//                              INITIALIZATION                                //
////////////////////////////////////////////////////////////////////////////////

/**
 * 1 MiB Heap Memory Space.
 */
const natq HEAP_START = 1*MiB;

/**
 * Heap memory space start address.
 */
extern "C" natq start;

/**
 * Heap memory space size.
 */
const natq HEAP_SIZE = (natq)&start - HEAP_START;

/**
 * Initial process.
 */
proc_elem init;

/**
 * Loads the tripple_fault_idt and call an interrupt 1. Implemented in system.s.
 */
extern "C" void end_program();

/**
 * Dummy process body.
 */
void dummy_body(int i)
{
    // wait until there is only one active user process (the dummy process
    // itself)
    while (user_processes != 1)
    {
        // wait for all user process to end execution
    }

    // where there is only the dummy process left, the system can be shutdown
    end_program();
}

/**
 * Creates the dummy process. Called at the end of initialization in  cmain().
 *
 * @return the dummy process id.
 */
natl create_dummy()
{
    // create dummy process
    proc_elem* dummy_elem = create_process(dummy_body, 0, DUMMY_PRIORITY, LEV_SYSTEM, true);
    
    // check if the dummy process was correctly created
    if (dummy_elem == 0)
    {
        // otherwise log error message
        flog(LOG_ERR, "Unable to create dummy process.");

        // return error code
        return 0xFFFFFFFF;
    }

    // insert dummy process in the processes list
    list_insert(ready_proc, dummy_elem);

    // increment user processes counter
    user_processes++;

    // return dummy process id
    return dummy_elem->id;
}

/**
 * System module main process method.
 *
 * @param  n
 */
void system_main(int n);

/**
 * Creates the System module main process.
 *
 * @return  the system main process id in case of success, 0xFFFFFFFF in case of
 *          error.
 */
natl create_system_main()
{
    // create system main process
    //  process body: system_main
    //  process prio: maximum priority
    //  process piv:  system level privilege
    proc_elem* m = create_process(system_main, 0, MAX_PRIORITY, LEV_SYSTEM, false);

    // check if the process was correctly create
    if (m == 0)
    {
        // if not, print a warning log message
        flog(LOG_ERR, "Unable to create the system_main process.");

        // return process creationg failed
        return 0xFFFFFFFF;
    }

    // insert system_main process in the system ready processes queue
    list_insert(ready_proc, m);

    // increment user processes counter
    user_processes++;

    // return system_main process id
    return m->id;
}

// ( [P_EXTERN_PROC]
// Registrazione processi esterni
proc_elem* const ESTERN_BUSY = (proc_elem*)1;

/**
 * Sends the EOI (end of interrupt) to the APIC and schedules a new process.
 */
extern "C" void wfi();

// associa il processo esterno puntato da "p" all'interrupt "irq".
// Fallisce se un processo esterno era gia' stato associato a
// quello stesso interrupt
bool aggiungi_pe(proc_elem *p, natb irq)
{
	if (irq >= MAX_IRQ) {
		flog(LOG_WARN, "irq %d non valido (max %d)", irq, MAX_IRQ);
		return false;
	}
	if (a_p[irq]) {
		flog(LOG_WARN, "irq %d occupato", irq);
		return false;
	}

	a_p[irq] = p;
	apic_set_MIRQ(irq, false);
	return true;
}

/**
 * Creates a new process for an external PCI device. The process is also
 * associated to the interrupts coming from the external device.
 *
 * @param  f     
 * @param  a     
 * @param  prio  process priority to be used;
 * @param  liv   
 * @param  type  
 */
extern "C" void c_activate_pe(void f(int), int a, natl prio, natl liv, natb type)
{
    // proc_elem for the new process
    proc_elem	*p;

    // retrieve current process descriptor
    des_proc *self = des_p(execution->id);

    // the given process priority can not be higher than the calling process
    if (prio < MIN_PRIORITY)
    {
        // print warning log message
        flog(LOG_WARN, "Invalid process priority: %d", prio);

        // abort current process
        c_abort_p();

        // just return to the calling function
        return;
    }

    // create new process with the given parameters: IF = true
    p = create_process(f, a, prio, liv, true);

    // check if the processo was correctly created
    if (p == 0)
    {
        goto error1;
    }

    // associate external device interrupts
    if ( !aggiungi_pe(p, type) )
    {
        // in case of failure go to error #2
        goto error2;
    }

    // log data of the newly created process for the external PCI device
    flog(LOG_INFO, "estern=%d entry=%p(%d) prio=%d liv=%d type=%d", p->id, f, a, prio, liv, type);

    self->context[I_RAX] = p->id;
	return;

error2:
    destroy_process(p);
error1:
	self->context[I_RAX] = 0xFFFFFFFF;
	return;
}

bool is_accessible(vaddr a)
{
	for (int i = 4; i > 0; i--) {
		natq d = get_des(execution->id, i, a);
		bool bitP = extr_P(d);
		if (!bitP)
			return false;
	}
	return true;
}

// indirizzo del primo byte che non contiene codice di sistema (vedi "sistema.s")
extern "C" addr fine_codice_sistema;

/**
 * Dumps the information related to the given log to console output.
 *
 * @param  id       the id of the process to be dumped;
 * @param  log_sev  the log severity to be used when logging process info.
 */
void process_dump(natl id, log_sev sev)
{
    // check if the given process id is valid
    if (!id)
    {
        flog(sev, "Invalid process id: %d.", id);
        return;
    }

    // retrieve process to be dumped
    des_proc *p = des_p(id);

    // check if the retrieved process is valid
    if (!p)
    {
        flog(sev, "Process %d not found.", id);
        return;
    }

    // retrieve process stack pointer
    natq *pila = (natq*)p->context[I_RSP];

    // log process stack
    flog(sev, "  RIP=%lx CPL=%s", pila[0], pila[1] == SEL_CODICE_UTENTE ? "LEV_USER" : "LEV_SYSTEM");

    // retrieve process rflags register
    natq rflags = pila[2];

    // log process rflags register content
    flog(sev, "  RFLAGS=%lx [%s %s %s %s %s %s %s %s %s %s, IOPL=%s]",
        rflags,                                 // Reserved
        (rflags & 1U << 14) ? "NT" : "nt",      // Nested task flag
        (rflags & 1U << 11) ? "OF" : "of",      // Overflow flag
        (rflags & 1U << 10) ? "DF" : "df",      // Direction flag
        (rflags & 1U << 9)  ? "IF" : "if",      // Interrupt enable flag
        (rflags & 1U << 8)  ? "TF" : "tf",      // Trap flag (single step)
        (rflags & 1U << 7)  ? "SF" : "sf",      // Sign flag
        (rflags & 1U << 6)  ? "ZF" : "zf",      // Zero flag
        (rflags & 1U << 4)  ? "AF" : "af",      // Adjust flag
        (rflags & 1U << 2)  ? "PF" : "pf",      // Parity flag
        (rflags & 1U << 0)  ? "CF" : "cf",      // Carry flag
        (rflags & 0x3000) == 0x3000 ? "USER" : "SYSTEM");

    // log %rax, %rbx, %rcx, %rdx registers content
    flog(sev, "  RAX=%lx RBX=%lx RCX=%lx RDX=%lx",
            p->context[I_RAX],
            p->context[I_RBX],
            p->context[I_RCX],
            p->context[I_RDX]);

    // log %rdi, %rsi, %rbp, %rsp registers content
    flog(sev, "  RDI=%lx RSI=%lx RBP=%lx RSP=%lx",
            p->context[I_RDI],
            p->context[I_RSI],
            p->context[I_RBP],
            pila[3] + 8);

    // log %r8, %r9, %r10, %r11 registers content
    flog(sev, "  R8 =%lx R9 =%lx R10=%lx R11=%lx",
            p->context[I_R8],
            p->context[I_R9],
            p->context[I_R10],
            p->context[I_R11]);
    
    // log %r12, %r13, %r14, %r15 registers content
    flog(sev, "  R12=%lx R13=%lx R14=%lx R15=%lx",
            p->context[I_R12],
            p->context[I_R13],
            p->context[I_R14],
            p->context[I_R15]);

    // log process backtrace
    flog(sev, "  backtrace:");

    // retrieve process stack base pointer
    natq rbp = p->context[I_RBP];

    for (;;)
    {
        natq* acsite = ((natq *)rbp + 1);
        
        if (((natq)acsite & 0x7) || !is_accessible((vaddr)acsite))
        {
            flog(sev, "  ! %lx", rbp);
            break;
        }
        
        addr csite = (addr)(*acsite - 5);
        
        if (csite < &start || csite >= fine_codice_sistema)
        {
            break;
        }

        flog(sev, "  > %lx", *((natq *)rbp + 1) - 5);
        
        rbp = *(natq *)rbp;
    }
}

/**
 * This method is the C++ implementation of the handler for the panic(cstr msg)
 * primitive implemented in system.s which calls the TIPO_P interrupt.
 *
 * @param  msg  string message describing the reason which led to the system
 *              panic.
 */
extern "C" void c_panic(const char *msg)
{
    // panic static index
    static int in_panic = 0;

    // check if panic alert has already been generated
    if (in_panic)
    {
        // print error log message
        flog(LOG_ERR, "Recursive panic. STOP");

        // shutdown
        end_program();
    }

    // set panic counter 
    in_panic = 1;

    // print error log message containing the panic message
    flog(LOG_ERR, "PANIC: %s", msg);

    // check if the current process under execution is valid
    if (execution->id)
    {
        // if so, dump the current process info
        process_dump(execution->id, LOG_ERR);
    }

    // log number of active user processes
    flog(LOG_ERR, "  active user processes: %d", user_processes - 1);

    // loop through all active user processes, for each of them
    for (natl id = MIN_PROC_ID; id < MAX_PROC_ID; id += 16)
    {
        // retrieve process descriptor
        des_proc *p = des_p(id);

        // check if the retrieved process descriptor is valod and if if is a
        // user process
        if (p && p->cpl == LEV_USER)
        {
            // if so, 
            vaddr v_eip = fin_sis_p - 5 * sizeof(natq);

            natq dp = get_des(id, 1, v_eip);

            natq ind_fis_pag = (natq)extr_IND_FISICO(dp);

            addr f_eip = (addr)(ind_fis_pag | (v_eip & 0xFFF));

            flog(LOG_ERR, "    *) proc=%d RIP=%p", id, *(natq*)f_eip);
		}
	}

    // shutdown
    end_program();
}

/**
 * If a non-maskerable interrupt is received, the system must be shut down.
 */
extern "C" void c_nmi()
{
    panic("Forced interrupt.");
}

/**
 * Returns the physical address corresponding to the given virtual address
 * inside the addressing space of the currently active process.
 *
 * @param  ind_virt  the virtual address to be translated into physical address.
 *
 * @return  the retrieved physical address or 0 if the virtual address is not
 *          successfully translated.
 */
extern "C" faddr c_trasforma(vaddr ind_virt)
{
    // memory table descriptor
    natq d;

    // loop through available memory tables levels starting from level 4,
    // for each level
    for (int liv = 4; liv > 0; liv--)
    {
        // get the entry descriptor for the given virtual address
        d = get_des(execution->id, liv, ind_virt);

        // check if the entry P bit is set
        if (!extr_P(d))
        {
            // if not, the entry is not available, print a warning log message
            flog(LOG_WARN, "Unable to transform %lx: not present at level %d", ind_virt, liv);

            // return 0
            return 0;
        }

        // if the P bit is set
        if (extr_PS(d))
        {
            // pagina di grandi dimensioni
            natq mask = (1UL << ((liv - 1) * 9 + 12)) - 1;
            return norm((d & ~mask) | (ind_virt & mask));
        }
    }

    return extr_IND_FISICO(d) | (ind_virt & 0xfff);
}

/**
 * Sets the interrupt type for the first 23 pins of the APIC.
 */
void apic_fill()
{
    apic_set_VECT(0, VETT_0);
    apic_set_VECT(1, VETT_1);
    apic_set_VECT(2, VETT_2);
    apic_set_VECT(3, VETT_3);
    apic_set_VECT(4, VETT_4);
    apic_set_VECT(5, VETT_5);
    apic_set_VECT(6, VETT_6);
    apic_set_VECT(7, VETT_7);
    apic_set_VECT(8, VETT_8);
    apic_set_VECT(9, VETT_9);
    apic_set_VECT(10, VETT_10);
    apic_set_VECT(11, VETT_11);
    apic_set_VECT(12, VETT_12);
    apic_set_VECT(13, VETT_13);
    apic_set_VECT(14, VETT_14);
    apic_set_VECT(15, VETT_15);
    apic_set_VECT(16, VETT_16);
    apic_set_VECT(17, VETT_17);
    apic_set_VECT(18, VETT_18);
    apic_set_VECT(19, VETT_19);
    apic_set_VECT(20, VETT_20);
    apic_set_VECT(21, VETT_21);
    apic_set_VECT(22, VETT_22);
    apic_set_VECT(23, VETT_23);
}

/**
 * Activates the system timer.
 *
 * @param  count  the value to be loaded into the timer CTR register.
 */
extern "C" void attiva_timer(natl count);

/**
 *
 */
const natl DELAY = 59659;

/**
 * Initializes the GDT.
 */
extern "C" void init_gdt();

/**
 * When the cmain() startup method is done executing, the System Module main
 * processo and the dummy process have been created. This method is called after
 * calling the schedule method (which sets execution = system_main) and loads
 * the process currently pointed by execution into the CPU.
 */
extern "C" void load_system_main();

/**
 * C++ STARTUP.
 * Called after the execution of _start, start defined in system.s.
 * The stack and the IDT have been initialized at this point.
 */
extern "C" void cmain()
{
    natl mid;

    // even though the first initial process is not yet completely initialized
    // we set its ID and priority in order to be able to identify it
    init.id = 0xFFFFFFFF;
    init.priority = MAX_PRIORITY;

    // set current process in execution
    execution = &init;

    // print welcome log message
    flog(LOG_INFO, "QEMU Linux Kernel, v5.12.6");

    // initialize GDT
    init_gdt();

    // log gdt initialized
    flog(LOG_INFO, "GDT Initialized.");

    // initialize system heap memory space
    heap_init((addr)HEAP_START, HEAP_SIZE);

    // log heap memory space initialized
    flog(LOG_INFO, "System heap: %x B @%x", HEAP_SIZE, HEAP_START);

    // 
    init_des_frame();
    flog(LOG_INFO, "Physical pages: %d", N_DF);

    // log system initialized memory spaces parameters
    flog(LOG_INFO, "sis/cond [%p, %p)", ini_sis_c, fin_sis_c);
    flog(LOG_INFO, "sis/priv [%p, %p)", ini_sis_p, fin_sis_p);
    flog(LOG_INFO, "io /cond [%p, %p)", ini_mio_c, fin_mio_c);
    flog(LOG_INFO, "usr/cond [%p, %p)", ini_utn_c, fin_utn_c);
    flog(LOG_INFO, "usr/priv [%p, %p)", ini_utn_p, fin_utn_p);

    faddr inittab4 = crea_tab4();

    if (!crea_finestra_FM(inittab4))
    {
        goto error;
    }

    // load newly initialized tab4 address in the cr3 register
    loadCR3(inittab4);

    // print info log message
    flog(LOG_INFO, "Initi Process CR3 loaded.");

    // [libqlk]: uses PIIX3 to initialize the APIC controller
    apic_init();

    // [libqlk]: resets all the APIC pins to default
    apic_reset();

    // set interrupt type for the first 23 pins of the APIC
    apic_fill();

    // print info log message
    flog(LOG_INFO, "APIC Initialized.");

    // initialize swap: start_io and start_user will be executed now as a result
    if (!swap_init())
    {
        goto error;
    }

    // log initialized swap memory block parameters
    flog(LOG_INFO, "sb: blocks = %d", swap_dev.sb.blocks);
    flog(LOG_INFO, "sb: user   = %p/%p", swap_dev.sb.user_entry, swap_dev.sb.user_end);
    flog(LOG_INFO, "sb: io     = %p/%p", swap_dev.sb.io_entry, swap_dev.sb.io_end);

    // create System module main process
    mid = create_system_main();

    // check if the process was correctly created
    if (mid == 0xFFFFFFFF)
    {
        // if not, got to error
        goto error;
    }

    // log system module main process id in case of success
    flog(LOG_INFO, "System module main process created (id = %d).", mid);

    // create dummy process
    dummy_proc = create_dummy();

    // check if the dummy process was corretly allocated
    if (dummy_proc == 0xFFFFFFFF)
    {
        // otherwise go to error
        goto error;
    }

    // log dummy process id
    flog(LOG_INFO, "Dummy processo created: (id = %d)", dummy_proc);

    // schedule next process: the system main process
    schedule();

    // load the scheduled process: currently the system module main process
    load_system_main();

error:
    c_panic("Initialization Error.");
}

/**
 *
 */
void gdb_breakpoint() {}

/**
 * Defined in system/sysyem.s calls an interrupt TIPO_A which will led to
 * a call to c_activate_p(...).
 */
extern "C" natl activate_p(void f(int), int a, natl prio, natl liv);

/**
 *
 */
extern "C" void terminate_p();

/**
 * System module main process body.
 *
 * @param  n
 */
void system_main(int n)
{
    // I/O module sync semaphore
    natl sync_io;

    // ( caricamento delle tabelle e pagine residenti degli spazi condivisi ()
    flog(LOG_INFO, "creazione o lettura delle tabelle e pagine residenti condivise...");
    
    if (!crea_spazio_condiviso())
    {
        goto error;
    }
 	// )

    gdb_breakpoint();

    // create I/O module process
    flog(LOG_INFO, "Creating I/O Module main process.");

    // initialize I/O module synchronization semaphore
    sync_io = sem_ini(0);

    // check if the semaphore was correctly allocate
    if (sync_io == 0xFFFFFFFF)
    {
        // if not, print a warning error log
        flog(LOG_ERR, "Unable to allocate the semaphore for I/O Module synchronization.");

        // go to error state
        goto error;
    }

    // occupiamo l'entrata del timer
    aggiungi_pe(ESTERN_BUSY, 2);

    // try to activate the I/O module process
    if (activate_p(swap_dev.sb.io_entry, sync_io, MAX_PRIORITY, LEV_SYSTEM) == 0xFFFFFFFF)
    {
        // in case of error, print a warning log message
        flog(LOG_ERR, "Unable to create I/O module main process.");
        goto error;
    }

    // waiting for the I/O module initialization to be complted
    flog(LOG_INFO, "Waiting for the I/O module initialization to be complted.");

    // wait I/O module synchronization sempahore
    sem_wait(sync_io);

    // create the user_start process
    flog(LOG_INFO, "Creating the start_user process.");

    // check if the start_user process was correctly activated
    if (activate_p(swap_dev.sb.user_entry, 0, MAX_PRIORITY, LEV_USER) == 0xFFFFFFFF)
    {
        // if not, print a warning error log
        flog(LOG_ERR, "Unable to create the User Module main process.");

        // go to error state
        goto error;
    }

    // cctivate system timer with the given CTR register value
    attiva_timer(DELAY);

    // log system timer correctly initialized
    flog(LOG_INFO, "Timer initialized (DELAY=%d)", DELAY);

	// finally, switch to user module process
    flog(LOG_INFO, "Switching to user process.");

    // terminate the process currently under execution
    terminate_p();

// in case of error, panic
error:
	panic("System main process initialization error.");
}

// ( [P_SWAP]
// lo swap e' descritto dalla struttura des_swap, che specifica il canale
// (primario o secondario) il drive (primario o master) e il numero della
// partizione che lo contiene. Inoltre, la struttura contiene una mappa di bit,
// utilizzata per l'allocazione dei blocchi in cui lo swap e' suddiviso, e un
// "super blocco".  Il contenuto del super blocco e' copiato, durante
// l'inizializzazione del sistema, dal primo settore della partizione di swap,
// e deve contenere le seguenti informazioni:
// - magic (un valore speciale che serve a riconoscere la partizione, per
// evitare di usare come swap una partizione utilizzata per altri scopi)
// - bm_start: il primo blocco, nella partizione, che contiene la mappa di bit
// (lo swap, inizialmente, avra' dei blocchi gia' occupati, corrispondenti alla
// parte utente/condivisa dello spazio di indirizzamento dei processi da
// creare: e' necessario, quindi, che lo swap stesso memorizzi una mappa di
// bit, che servira' come punto di partenza per le allocazioni dei blocchi
// successive)
// - blocks: il numero di blocchi contenuti nella partizione di swap (esclusi
// quelli iniziali, contenenti il superblocco e la mappa di bit)
// - directory: l'indice del blocco che contiene la tabella di livello 4
// - l'indirizzo virtuale dell'entry point del programma contenuto nello swap
// (l'indirizzo di main)
// - l'indirizzo virtuale successivo all'ultima istruzione del programma
// contenuto nello swap
// - l'indirizzo virtuale dell'entry point del modulo io contenuto nello swap
// - l'indirizzo virtuale successivo all'ultimo byte occupato dal modulo io
// - checksum: somma dei valori precedenti (serve ad essere ragionevolmente
// sicuri che quello che abbiamo letto dall'hard disk e' effettivamente un
// superblocco di questo sistema, e che il superblocco stesso non e' stato
// corrotto)
//

// usa l'istruzione macchina BSF (Bit Scan Forward) per trovare in modo
// efficiente il primo bit a 1 in v
extern "C" int trova_bit(natl v);
void scrivi_swap(addr src, natl blocco);
void leggi_swap(addr dest, natl blocco);

natl ceild(natl v, natl q)
{
	return v / q + (v % q != 0 ? 1 : 0);
}

natq alloca_blocco()
{
	natl i = 0;
	natq risu = 0;
	natq vecsize = ceild(swap_dev.sb.blocks, sizeof(natl) * 8);

	// saltiamo le parole lunghe che contengono solo zeri (blocchi tutti occupati)
	while (i < vecsize && swap_dev.free[i] == 0) i++;
	if (i < vecsize) {
		natl pos = __builtin_ffs(swap_dev.free[i]) - 1;
		swap_dev.free[i] &= ~(1UL << pos);
		risu = pos + sizeof(natl) * 8 * i;
	}
	return risu;
}

void dealloca_blocco(natl blocco)
{
	if (blocco == 0)
		return;
	swap_dev.free[blocco / 32] |= (1UL << (blocco % 32));
}



// legge dallo swap il blocco il cui indice e' passato come primo parametro,
// copiandone il contenuto a partire dall'indirizzo "dest"
void leggi_swap(addr dest, natl blocco)
{
	natl sector = blocco * 8;

	hdd_read(sector, 8, static_cast<natw*>(dest));
}

void scrivi_swap(addr src, natl blocco)
{
	natl sector = blocco * 8;

	hdd_write(sector, 8, static_cast<natw*>(src));
}

/**
 * SWAP HDD read buffer.
 */
natw read_buf[256];

/**
 * Initializes the SWAP HDD.
 */
bool swap_init()
{
    // print info log message
    flog(LOG_DEBUG, "Reading SWAP HDD Superblock.");

    // read swap hdd superblock: A superblock is a record of the characteristics
    // of a filesystem, including its size, the block size, the empty and the
    // filled blocks and their respective counts, the size and location of the
    // inode tables, the disk block map and usage information, and the size of
    // the block groups.
    hdd_read(1, 1, read_buf);

    // for each mounted filesystem, Linux also maintains a copy of its
    // superblock in memory
    swap_dev.sb = *reinterpret_cast<superblock_t*>(read_buf);

    // check if the superblock actually contains the corrent magic number
    for (int i = 0; i < 8; i++)
    {
        // check
        if (swap_dev.sb.magic[i] != "CE64SWAP"[i])
        {
            // if not, print a warning log message
            flog(LOG_ERR, "SWAP HDD wrong magic number.");

            // return swap initialization failed
            return false;
        }
    }

	// superblock checksum: A checksum is a small-sized datum derived from a
    // block of digital data for the purpose of detecting errors that may have
    // been introduced during its transmission or storage
    int *w = (int*)&swap_dev.sb, sum = 0;

    //
    for (natl i = 0; i < sizeof(swap_dev.sb) / sizeof(int); i++)
    {
        sum += w[i];
    }

    // check if the sum is equal to zero
    if (sum != 0)
    {
        // if so, print a warning log message
        flog(LOG_ERR, "SWAP HDD Checksum error.");

        // return swap initialization failed
        return false;
	}

    flog(LOG_DEBUG, "lettura della bitmap dei blocchi...");

	// calcoliamo la dimensione della mappa di bit in pagine/blocchi
	natl pages = ceild(swap_dev.sb.blocks, DIM_PAGINA * 8);

	// quindi allochiamo in memoria un buffer che possa contenerla
	swap_dev.free = static_cast<natl*>(alloca((pages * DIM_PAGINA)));
	if (swap_dev.free == 0) {
		flog(LOG_ERR, "Impossibile allocare la bitmap dei blocchi");
		return false;
	}
	// infine, leggiamo la mappa di bit dalla partizione di swap
	hdd_read(swap_dev.sb.bm_start * 8, pages * 8, reinterpret_cast<natw*>(swap_dev.free));
	return true;
}

/**
 * Semaphore are never deallocated and they can therefore be allocated
 * sequentially. In order to do so we will gave to keep track of the number
 * of allocated ones.
 */
natl allocated_sems = 0;

/**
 * Allocates a new semaphore and returns its number.
 *
 * @return  the number of the allocated semaphore.
 */
natl alloca_sem()
{
    natl i;

    // check if maximum number of allocable semaphore has been reached
    if (allocated_sems >= MAX_SEM)
    {
        return 0xFFFFFFFF;
    }

    // set semaphore number
    i = allocated_sems;

    // increment number of semaphores
    allocated_sems++;

    // return semaphore number
    return i;
}

// dal momento che i semafori non vengono mai deallocati,
// un semaforo e' valido se e solo se il suo indice e' inferiore
// al numero dei semafori allocat
/**
 * Checks if the given semaphore ID is valid: since semaphore are never
 * deallocated it only checks if the given id is lower than the number of
 * allocated semaphores.
 */
bool sem_valido(natl sem)
{
    return sem < allocated_sems;
}

/**
 * C++ body implementation for the a_sem_ini primitive.
 * Together they implement the sem_ini kernel primitive.
 */
extern "C" natl c_sem_ini(int val)
{
    // allocate semaphore
    natl i = alloca_sem();

    // check if there are still available semaphores
    if (i != 0xFFFFFFFF)
    {
        // set semaphore counter value
        array_dess[i].counter = val;
    }

    // return semaphore id
    return i;
}
// )
#ifdef AUTOCORR
int MAX_LOG = 4;
#else
int MAX_LOG = 5;
#endif

extern "C" void c_log(log_sev sev, const char* buf, natl quanti)
{
	do_log(sev, buf, quanti);
}


